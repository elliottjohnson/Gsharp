;;; This file contains undo functionality for GSharp based on code
;;; contained in mcclim's Drei editor substrate. Drei code keeps track
;;; of the `undo tree', but several changes were needed in GSharp to
;;; support this:
;;;    *  BUFFER is now a DREI::UNDO-MIXIN
;;;    *  EXECUTE-FRAME-COMMAND has an around method calling WITH-UNDO
;;;
;;; And in this file, each `atomic' operation in GSHARP is given:
;;;    *  a subclass of DREI-UNDO-RECORD
;;;    *  a meaningful PRINT-OBJECT method
;;;    *  an inverse method FLIP-UNDO-RECORD
;;;
;;; Each operation's function or method is also altered to accomodate
;;; undo recording.

(cl:in-package #:gsharp)

;; General utils first
(defgeneric element-children (element)
  (:method ((c cluster)) (notes c))
  (:documentation  "Return the notes of a cluster or the elements of a ligature"))
(defmethod (setf element-children) (children (cluster cluster))
  (setf (notes cluster) children))
(defun insert-element-sequence (bar pos sequence)
  "Inserts elements of SEQUENCE in order into the given BAR at POS"
  (let ((cursor (make-cursor bar pos)))
    (dolist (object sequence)
      (cond
        ((typep object 'bar)
         (insert-bar-after 
          (make-instance (class-of object))
          cursor))
        (t (insert-element object cursor)
           (forward-element cursor))))))
(defun element-sequence (bar pos length)
  "Equivalent of SUBSEQ for elements in a layer."
  (let ((cursor (make-cursor bar pos)))
    (loop for i from 0 below length
       collect (if (end-of-bar-p cursor)
                   (bar cursor)
                   (progn 
                     (forward-element cursor)
                     (current-element cursor))))))
(defun delete-element-range (bar pos length)
  "Deletes LENGTH elements at BAR/POS"
  (let ((cursor (make-cursor bar pos)))
    (dotimes (i length)
      (delete-element cursor))))
(defun insert-subobject-sequence (objects sequence offset)
  "Inserts OBJECTS into SEQUENCE at OFFSET.
e.g. (INSERT-SUBOBJECT-SEQUENCE '(A B) '(1 2 3 4 5) 2) => (1 2 A B 3 4 5)"
  (let ((tail (nthcdr offset sequence))
        (objects (copy-seq objects)))
    (setf (cdr (nthcdr (1- offset) sequence)) objects
          (cdr (last objects)) tail)))
(defun delete-child-sequence (sequence offset length)
  "Deletes LENGTH elements from SEQUENCE starting at OFFSET."
  (let ((tail (nthcdr (+ offset length) sequence)))
    (setf (cdr (nthcdr (1- offset) sequence)) tail)
    sequence))

;; A key difference between undo in the text and score worlds is that
;; offset is not enough in the latter case, since we no longer have
;; linear data. There are several obvious ways to try it:
;;
;; * A GSHARP-CURSOR is an obvious alternative, but information is
;; lost when cursors bunch up after a series of deletes and cannot be
;; recovered. e.g.
;;  step 1: Insert C (elements: C) 
;;  step 2: Insert D (elements: C-D)
;;  step 3: Delete D (elements: C)
;;  step 4: Delete C (elements: -)
;;  step 5: Undo (elements C)
;;  step 6: Undo (elements D-C) <--- Cursor for D undo is at 0 pos
;;
;; * Keeping track of BAR and POSITION without the cursor structure is
;; fine until a barline is deleted, at which point, BAR may no longer
;; exist, and POSITION may point to the wrong place
;;
;; * We know that if actions are properly controlled, the state
;; immediately before and after undo is known at the time of
;; UNDO-RECORD creation, so we can get the position by BAR-NO/POSITION
;; co-ordinates.
;; 
;; * Neighbouring elements should be predictable. Perhaps we could store
;; these.
;;
;; Having tried the first two and found the problems quite quickly,
;; I'm now trying the third.
;;
;; Notes within elements are easy, since we just use the element.

(defclass gsharp-undo-record (drei::drei-undo-record)
  ())
(defclass gsharp-element-undo-record (gsharp-undo-record)
  ((slice :initarg :slice :reader slice)
   (bar-number :initarg :bar :reader undo-bar)
   (pos :initarg :pos :reader undo-pos))
  (:documentation "Generated by an action that adds or removes
  ELEMENTs. Identifying the location of changes is not always
  easy. Here it is achieved by a combination of SLICE, BAR-NUMBER,
  POS. Note that BAR cannot be used, since its identity may
  change. SLICE is assumed not to do so. Otherwise, that too will need
  to be indicated numerically."))
(defclass gsharp-child-undo-record (gsharp-undo-record)
  ((element :initarg :element :reader undo-element)
   (offset :initarg :offset :reader undo-offset))
  (:documentation "Generated by an action that adds or removes
  NOTEs. The parent ELEMENT is stored directly, whilst an OFFSET
  indicates where the change occured."))
(defclass gsharp-specific-thing-undo-record (gsharp-undo-record)
  ((thing :initarg :thing :reader undo-thing))
  (:documentation "Generated by an action that changes an object, but
  doesn't change its identity. This makes life easier, since undo
  operations can be can be carried out directly on the object."))

(defclass gsharp-bar-record (gsharp-undo-record)
  ((bar-number :initarg :bar :reader undo-bar)
   (slice :initarg :slice :reader slice)))
(defclass gsharp-bar-insert-record (gsharp-bar-record)
  ((class :initarg :class :reader undo-bar-class)
   (barline :initarg :barline :reader undo-barline)))
(defclass gsharp-bar-delete-record (gsharp-bar-record)
  ())

(defclass insert-mixin ()
  ((objects :initarg :objects :reader undo-objects)))
(defclass gsharp-element-insert-record (insert-mixin gsharp-element-undo-record)
  ())
(defclass gsharp-child-insert-record (insert-mixin gsharp-child-undo-record)
  ())
(defclass delete-mixin ()
  ((length :initarg :length :reader undo-length)))
(defclass gsharp-element-delete-record (delete-mixin gsharp-element-undo-record)
  ())
(defclass gsharp-child-delete-record (delete-mixin gsharp-child-undo-record)
  ())
(defclass change-mixin ()
  ((objects :initarg :objects :reader undo-objects)))
(defclass gsharp-element-change-record (change-mixin gsharp-element-undo-record)
  ())
(defclass gsharp-child-change-record (change-mixin gsharp-child-undo-record)
  ())
(defclass gsharp-slot-change-record (gsharp-specific-thing-undo-record)
  ((slot-changes :initarg :changes :accessor undo-slot-changes)))

(defmethod drei-undo::flip-undo-record ((record gsharp-element-insert-record))
  (with-slots (slice bar-number pos) record
    (let ((bar (barno slice bar-number))
          (objects (slot-value record 'objects)))
      (change-class record 'gsharp-element-delete-record
                    :length (length objects))
      (insert-element-sequence bar pos objects))))
(defmethod drei-undo::flip-undo-record ((record gsharp-element-delete-record))
  (with-slots (slice bar-number pos) record
    (let ((bar (barno slice bar-number))
          (length (undo-length record)))
      (change-class record 'gsharp-element-insert-record
                    :objects (element-sequence bar pos length))
      (delete-element-range bar pos length))))
;; FIXME::I'll add this when I make an op that needs it
#+nil
(defmethod drei-undo::flip-undo-record ((record gsharp-element-change-record)))
(defmethod drei-undo::flip-undo-record ((record gsharp-child-insert-record))
  (with-slots (element offset) record
    (let ((objects (slot-value record 'objects)))
      (change-class record 'gsharp-child-delete-record
                    :length (length objects))
      (if (= offset 0)
          (setf (element-children element) objects)
          (insert-subobject-sequence objects (element-children element) offset)))))
(defmethod drei-undo::flip-undo-record ((record gsharp-child-delete-record))
  (with-slots (element offset) record
    (let ((length (slot-value record 'length)))
      (change-class record 'gsharp-child-insert-record
                    :objects (subseq (element-children element) 
                                     offset (+ length offset)))
      (if (= offset 0)
          (setf (element-children element) (subseq (element-children element) length))
          (delete-child-sequence (element-children element) offset length)))))
;; FIXME::I'll add this when I make an op that needs it
#+nil
(defmethod drei-undo::flip-undo-record ((record gsharp-child-change-record)))
(defmethod drei-undo::flip-undo-record ((record gsharp-slot-change-record))
  (with-slots (thing slot-changes) record
    (loop for change in slot-changes
       do (rotatef (cdr change) (slot-value thing (car change))))))

(defmethod drei-undo::flip-undo-record ((record gsharp-bar-insert-record))
  (let* ((type (undo-bar-class record))
         (pos (undo-bar record))
         (slice (slice record))
         (bar (barno slice pos)))
    (change-class record 'gsharp-bar-delete-record)
    (insert-bar-after (make-instance type)
                      (make-cursor bar (length (elements bar))))))
(defmethod drei-undo::flip-undo-record ((record gsharp-bar-delete-record))
  (let* ((slice (slice record))
         (pos (undo-bar record))
         (bar1 (barno slice pos))
         (bar2 (barno slice (1+ pos)))
         (cursor (make-cursor bar1 (length (elements bar1)))))
    (change-class record 'gsharp-bar-insert-record
                  :class (class-of bar2))
    (fuse-bar-with-next cursor)))

(defmethod add-element :before (element bar position)
  (let* ((slice (slice bar))
         (buffer (buffer (segment (layer slice)))))
    (unless (drei:performing-undo buffer)
      (push (make-instance 'gsharp-element-delete-record
                           :length 1
                           :bar (number bar) :pos position
                           :slice slice :buffer buffer)
            (drei:undo-accumulate buffer)))))

(defmethod add-note :before (cluster note)
  (let* ((buffer (buffer (segment (layer (slice (bar cluster)))))))
    (unless (drei:performing-undo buffer)
      (push (make-instance 'gsharp-child-delete-record
                           :length 1 :element cluster
                           :offset (length (notes cluster))
                           :buffer buffer)
            (drei:undo-accumulate buffer)))))

(defmethod delete-element :before (cursor)
  (with-slots (bar (pos gsharp-cursor::pos)) cursor
    (let ((slice (slice (bar cursor)))
          (buffer (buffer cursor))
          (bar-num (number bar)))
      (unless (drei:performing-undo buffer)
        (push (if (end-of-bar-p cursor)
                  (let ((bar-to-delete (barno slice (1+ bar-num))))
                    (make-instance 'gsharp-bar-insert-record
                                   :class (class-of bar-to-delete)
                                   :slice slice :buffer buffer
                                   :bar bar-num))
                  (make-instance 'gsharp-element-insert-record
                                 :objects (list (elementno bar pos))
                                 :bar bar-num :pos pos
                                 :slice slice :buffer buffer))
              (drei:undo-accumulate buffer))))))

(defmethod insert-bar-after :before (bar cursor)
  (let ((buffer (buffer cursor)))
    (unless (drei:performing-undo buffer)
      (push (make-instance 'gsharp-bar-delete-record 
                           :slice (slice cursor)
                           :bar (number (bar cursor))
                           :buffer buffer)
            (drei:undo-accumulate buffer)))))

(defmethod buffer ((cluster cluster))
  (buffer (segment (layer (slice (bar cluster))))))
(defmethod buffer ((note note))
  (buffer (segment (layer (slice (bar (cluster note)))))))

(macrolet ((slot-setf-undo (method-name &key element-specializer value
                                        buffer-method slot)
             (let ((accessor (if value
                                 `(funcall ,value 'object)
                                 `(slot-value object ',method-name)))
                   (l-list (if element-specializer
                               `(object ,element-specializer)
                               'object))
                   (buf (if buffer-method 
                            `(funcall ,buffer-method object)
                            `(buffer object))))
               (unless slot
                 (setf slot method-name))
               `(defmethod (setf ,method-name) :before (val ,l-list)
                  (let ((buffer ,buf))
                    (unless (drei:performing-undo buffer)
                      (push (make-instance 'gsharp-slot-change-record
                                           :changes (list (cons ',slot
                                                                ,accessor))
                                           :thing object
                                           :buffer buffer)
                            (drei:undo-accumulate buffer))))))))
  (slot-setf-undo gsharp-buffer::staff-pos)
  (slot-setf-undo gsharp-buffer::notehead :element-specializer element)
  (slot-setf-undo gsharp-buffer::rbeams :element-specializer element)
  (slot-setf-undo gsharp-buffer::lbeams :element-specializer element)
  
  (slot-setf-undo stem-direction
                  :element-specializer cluster
                  :value 'stem-direction)
  
  (slot-setf-undo gsharp-buffer::dots)
  
  (slot-setf-undo gsharp-buffer::set-contents :element-specializer cluster
                  :value #'(lambda (x) (copy-seq (notes x))) :slot notes))
